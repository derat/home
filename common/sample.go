// Copyright 2017 Daniel Erat <dan@erat.org>
// All rights reserved.

package common

import (
	"fmt"
	"strconv"
	"strings"
	"time"
)

type Sample struct {
	Timestamp time.Time
	Name      string
	Value     float64
}

// String serializes s to a string that can later be parsed using Parse.
func (s *Sample) String() string {
	return fmt.Sprintf("%d|%s|%.1f", s.Timestamp.Unix(), s.Name, s.Value)
}

// Parse deserializes str, previously generated by String, and fills s. If a
// timestamp is not supplied, now will be used. On error, s may be left in a
// partially-initialized state.
func (s *Sample) Parse(str string, now time.Time) error {
	parts := strings.Split(str, "|")
	if len(parts) != 2 && len(parts) != 3 {
		return fmt.Errorf("Expected 2 or 3 parts in %q", str)
	}

	if len(parts) == 3 {
		ut, err := strconv.ParseInt(parts[0], 10, 64)
		if err != nil {
			return fmt.Errorf("Failed to parse timestamp from %q", str)
		}
		s.Timestamp = time.Unix(ut, 0)
	} else {
		s.Timestamp = now
	}

	s.Name = parts[len(parts)-2]
	var err error
	if s.Value, err = strconv.ParseFloat(parts[len(parts)-1], 64); err != nil {
		return fmt.Errorf("Failed to parse value from %q", str)
	}
	return nil
}
