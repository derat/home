// Copyright 2017 Daniel Erat <dan@erat.org>
// All rights reserved.

package common

import (
	"fmt"
	"strconv"
	"strings"
	"time"
)

type Sample struct {
	Timestamp time.Time
	Source    string
	Name      string
	Value     float32 `datastore:",noindex"`
}

// String serializes s to a string that can later be parsed using Parse.
func (s *Sample) String() string {
	return fmt.Sprintf("%d|%s|%s|%.1f", s.Timestamp.Unix(), s.Source, s.Name, s.Value)
}

// Parse deserializes str, previously generated by String, and fills s. If a
// timestamp is not supplied, now will be used. On error, s may be left in a
// partially-initialized state.
func (s *Sample) Parse(str string, now time.Time) error {
	parts := strings.Split(str, "|")
	if len(parts) != 3 && len(parts) != 4 {
		return fmt.Errorf("Expected 3 or 4 parts in %q", str)
	}

	if len(parts) == 4 {
		ut, err := strconv.ParseInt(parts[0], 10, 64)
		if err != nil {
			return fmt.Errorf("Failed to parse timestamp from %q", str)
		}
		s.Timestamp = time.Unix(ut, 0)
	} else {
		s.Timestamp = now
	}

	s.Source = parts[len(parts)-3]
	s.Name = parts[len(parts)-2]
	if val, err := strconv.ParseFloat(parts[len(parts)-1], 64); err != nil {
		return fmt.Errorf("Failed to parse value from %q", str)
	} else {
		s.Value = float32(val)
	}
	return nil
}

// JoinSamples joins the string representations of samples with newlines.
func JoinSamples(samples []Sample) string {
	d := make([]string, len(samples))
	for i, s := range samples {
		d[i] = s.String()
	}
	return strings.Join(d, "\n")
}
